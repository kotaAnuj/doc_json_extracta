<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Gemini Document Extractor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f7f7f7;
      margin: 20px;
      padding: 0;
    }
    .container {
      max-width: 600px;
      margin: auto;
      background: #fff;
      padding: 20px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1, h2 {
      text-align: center;
      color: #333;
    }
    form {
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    input[type="file"] {
      padding: 5px;
    }
    button {
      padding: 10px;
      font-size: 16px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #357ae8;
    }
    pre {
      background-color: #eee;
      padding: 10px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Gemini Document Extractor</h1>
    <form id="uploadForm">
      <label for="document">Select a document (PDF, image, text, audio, video, etc.):</label>
      <input type="file" id="document" name="document" required>
      <button type="submit">Upload and Extract</button>
    </form>
    <h2>Extraction Result</h2>
    <pre id="result">Awaiting upload...</pre>
  </div>

  <script>
    // --------------- Configuration ---------------
    // WARNING: Do not expose your API key in production!
    const API_KEY = "YOUR_API_KEY_HERE";  // Replace with your actual Gemini API key
    const BASE_UPLOAD_URL = `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${API_KEY}`;
    const GENERATE_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`;
    
    // --------------- Helper Functions ---------------
    // Function to start a resumable upload by sending metadata
    async function startUpload(file) {
      const headers = {
        "X-Goog-Upload-Protocol": "resumable",
        "X-Goog-Upload-Command": "start",
        "X-Goog-Upload-Header-Content-Length": file.size,
        "X-Goog-Upload-Header-Content-Type": file.type,
        "Content-Type": "application/json"
      };
      const body = JSON.stringify({
        file: { display_name: file.name }
      });
      
      const response = await fetch(BASE_UPLOAD_URL, {
        method: "POST",
        headers,
        body
      });
      if (!response.ok) {
        throw new Error("Failed to start upload: " + response.statusText);
      }
      // Read the resumable upload URL from the response header.
      const uploadUrl = response.headers.get("x-goog-upload-url");
      if (!uploadUrl) {
        throw new Error("Upload URL not provided in response headers.");
      }
      return uploadUrl;
    }
    
    // Function to upload the file bytes via the upload URL
    async function uploadFileBytes(uploadUrl, file) {
      const headers = {
        "Content-Length": file.size,
        "X-Goog-Upload-Offset": "0",
        "X-Goog-Upload-Command": "upload, finalize"
      };
      const response = await fetch(uploadUrl, {
        method: "POST",
        headers,
        body: file
      });
      if (!response.ok) {
        throw new Error("Failed to upload file bytes: " + response.statusText);
      }
      const json = await response.json();
      // Expect the JSON response to contain the file URI.
      return json.file.uri;
    }
    
    // Function to call Gemini generateContent with the file URI
    async function generateContent(fileUri, fileMimeType) {
      const payload = {
        contents: [
          {
            parts: [{ text: "Please extract key information from this document and return valid JSON." }]
          },
          {
            parts: [{
              file_data: {
                fileUri: fileUri,
                mimeType: fileMimeType
              }
            }]
          }
        ]
      };
      const response = await fetch(GENERATE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        throw new Error("Failed to generate content: " + response.statusText);
      }
      const result = await response.json();
      // Assume the structured JSON result is in result.response.text()
      // Depending on the API, you may need to traverse the result object.
      return result.response ? result.response.text : null;
    }
    
    // --------------- Main Form Handling ---------------
    document.getElementById("uploadForm").addEventListener("submit", async (event) => {
      event.preventDefault();
      const resultPre = document.getElementById("result");
      resultPre.textContent = "Uploading file and processing...";
      
      try {
        const file = document.getElementById("document").files[0];
        if (!file) {
          resultPre.textContent = "Please select a file.";
          return;
        }
        
        // Step 1: Start the upload and get the resumable URL.
        const uploadUrl = await startUpload(file);
        console.log("Resumable upload URL:", uploadUrl);
        
        // Step 2: Upload the file bytes to the upload URL.
        const fileUri = await uploadFileBytes(uploadUrl, file);
        console.log("File uploaded. File URI:", fileUri);
        
        // Step 3: Call Gemini generateContent with the file URI.
        const jsonResponse = await generateContent(fileUri, file.type);
        console.log("Gemini response (raw):", jsonResponse);
        
        // Try to parse the JSON response.
        let formatted;
        try {
          const parsed = JSON.parse(jsonResponse);
          formatted = JSON.stringify(parsed, null, 2);
        } catch (e) {
          formatted = jsonResponse; // Fallback: show as is.
        }
        resultPre.textContent = formatted;
      } catch (error) {
        console.error("Error:", error);
        resultPre.textContent = "Error: " + error.message;
      }
    });
  </script>
</body>
</html>
